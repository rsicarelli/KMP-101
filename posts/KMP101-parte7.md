## Explorando as palavras reservadas 'actual/expect' no KMP

Nos √∫ltimos artigos, focamos mais nos "bastidores" do KMP: paradigma, arquitetura do compilador, os source sets, ambiente de desenvolvimento, cria√ß√£o e execu√ß√£o de um projeto de exemplo, e o papel do Gradle nisso tudo.

Dessa vez, vamos come√ßar iniciar nossa jornada para a superf√≠cie do KMP, entendendo sobre as palavras reservadas `actual` e `expect` e seu papel no compartilhamento do c√≥digo.


---

## Como o KMP possibilita o compartilhamento do c√≥digo

No artigo [üîó Dominando os princ√≠pios dos Source Sets](https://dev.to/rsicarelli/kotlin-multiplataforma-101-dominando-os-principios-dos-source-sets-4pg), aprendemos que o KMP se utiliza da estrutura de source sets, e que todo source-set espec√≠fico √© descendente do source-set ra√≠z `commonMain`. Todo c√≥digo Kotlin dentro do source-set `commmonMain` est√° automagicamente dispon√≠vel nos source-sets espec√≠ficos como o `androidMain`, `appleMain`, etc.

O c√≥digo Kotlin compartilhado no `commonMain` pode ser:

1. Gen√©rico o bastante que conseguimos resolver apenas com o Kotlin
2. Compartilha certos comportamentos, por√©m a implementa√ß√£o difere devido √† necessidade ou peculiaridade de cada plataforma

> Lembrando que, independente do tipo de compartilhamento, o Kotlin sempre ir√° compilar para c√≥digo nativo.

Vamos entender melhor sobre cada um desse tipo.

### 1. Compartilhando c√≥digo gen√©rico utilizando 100% Kotlin

Esse tipo de compartilhamento infere que n√£o h√° nenhuma implementa√ß√£o espec√≠fica que precisa ser feita no lado nativo, nos possibilitando utilizar apenas o Kotlin para satisfazer nosso requisito.

No in√≠cio do KMP, esse tipo de compartilhamento poderia n√£o ser t√£o comum, j√° que a comunidade do c√≥digo livre ainda estava se aquecendo e bibliotecas KMP estavam se formando. Atualmente, dado ao leque de c√≥digo livre dispon√≠vel para nosso uso, √© o formato mais comum para compartilhamento de c√≥digo.

#### Constantes

Constante √© aquele tipo de informa√ß√£o que √© est√°tica e super espec√≠fica. √â um tipo de informa√ß√£o que, geralmente, tem um tipo primitivo (`String`, `Int`, `Boolean`, etc) e se repete para todas as plataformas.

```kotlin
object AppConfig {
    const val API_KEY: String = "your_api_key"
    const val ENVIRONMENT: String = "production"
}

object AuthConfig {
    const val LOGIN_URL: String = "https://..."
    const val TOKEN_EXPIRY: Long = 3600 // 1 hora em segundos
}

object UIConfig {
    const val PRIMARY_COLOR: String = "#FF5733"
    const val FONT_SIZE: Int = 14
}

object ErrorMessages {
    const val NETWORK_ERROR: String = "Erro de conex√£o com a internet."
    const val LOGIN_FAILED: String = "Falha no login, tente novamente."
}

object DatabaseConfig {
    const val DB_URL: String = "jdbc:mysql://localhost:3306/mydb"
    const val TABLE_USER: String = "users"
}

object DomainSpecific {
    const val TAX_RATE: Double = 0.2
    const val MAX_DISCOUNT: Double = 50.0
    const val FAQ_URL: String = "https://..."
}

object WebServiceRoutes {
    private const val BASE_URL: String = "https://api.example.com/"
    const val USER_PROFILE: String = "${BASE_URL}user/profile"
    const val PRODUCT_LIST: String = "${BASE_URL}product/list"
}

object AnalyticsEvents {
    const val BUTTON_CLICKED_EVENT_NAME: String = "..."
}
```

#### Modelos: entidades, DTO, objetos de valor, respostas e requisi√ß√µes com um servidor

Modelos geralmente refletem informa√ß√µes mais espec√≠ficas do neg√≥cio, e na grande maioria das vezes n√£o requerem nenhuma implementa√ß√£o espec√≠fica de plataforma.

Compartilhar modelos vai al√©m da conveni√™ncia, mas tamb√©m refor√ßa uma linguagem de dom√≠nio √∫nico para todo o time de frontend (mobile, web e desktop). Para os praticantes do [Domain Driven Design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), essa pr√°tica √© um artefato extremamente poderoso, j√° que dessa forma, o time ter√° um √∫nico dicion√°rio do dom√≠nio.

```kotlin
data class User(
    val id: Int,
    val name: String,
    val email: String
) {
    init {
        require(id != 0)
        require(name.isNotBlank())
        require(email.isNotBlank())
    }
}
```
```kotlin
data class UserDTO(
    val name: String,
    val email: String
)
```
```kotlin
data class Money(
    val amount: Double,
    val currency: String
)
```

Gra√ßas ao [kotlin.serialization](https://github.com/Kotlin/kotlinx.serialization), n√£o precisamos nos preocupar com implementa√ß√µes espec√≠ficas de cada plataforma. Isso possibilita utilizar apenas c√≥digo Kotlin para configurar a serializa√ß√£o e deserializa√ß√£o dos objetos conforme demonstrado a seguir.

```kotlin
@Serializable
data class ApiResponse<T>(
    @SerialName("data")
    val data: T,

    @SerialName("message")
    val message: String? = null,

    @SerialName("status")
    val status: Int
)
```
```kotlin
@Serializable
data class LoginRequest(
    @SerialName("username")
    val username: String,

    @SerialName("password")
    val password: String
)
```

> ‚è±Ô∏è Vamos aprender sobre essa biblioteca nos pr√≥ximos artigos

#### L√≥gica de neg√≥cio

A natureza de uma regra de neg√≥cio √© geralmente agn√≥stica a plataforma, e imposta pelo contexto espec√≠fico do seu projeto, sendo um candidato perfeito para ser solucionado apenas com Kotlin.

Al√©m de impor o mesmo comportamento de neg√≥cio para todas as plataformas, compartilhar a regra de neg√≥cio tamb√©m significa compartilhar os testes unit√°rios e integra√ß√£o dessa regra. Ao inv√©s de repetir o mesmo teste em cada plataforma, testaremos apenas uma vez.

```kotlin
interface AccountRepository {
    val currentBalance: Double
}

class CheckBalanceForTransferUseCase(
    val accountRepository: AccountRepository
) {
    operator fun invoke(valueToTransfer: Double): CheckBalanceForTransferResult {
        require(valueToTransfer > 0)

        val currentBalance: Double = accountRepository.currentBalance

        return if (currentBalance >= valueToTransfer)
            HasSufficientFunds
        else InsufficientFunds(missingAmount = valueToTransfer - currentBalance)
    }

    sealed interface CheckBalanceForTransferResult {
        data object HasSufficientFunds : CheckBalanceForTransferResult
        data class InsufficientFunds(val missingAmount: Double) : CheckBalanceForTransferResult
    }
}
```

> No mundo do Kotlin/Android, o uso do padr√£o [UseCase](https://en.wikipedia.org/wiki/Use_case) se tornou uma pr√°tica comum e constantemente utilizada em projetos inner e open source.
> 
> Existem diversas formas de criar UseCases no Kotlin, caso tenha curiosidade em aprender outras formas:
> 
> [üîó How To Avoid Use Cases Boilerplate in Android](https://betterprogramming.pub/how-to-avoid-use-cases-boilerplate-in-android-d0c9aa27ef27)




